<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover, minimal-ui"
    />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="apple-touch-fullscreen" content="yes" />
    <meta name="theme-color" content="#0a0a0a" />
    <meta name="msapplication-navbutton-color" content="#0a0a0a" />
    <meta name="apple-mobile-web-app-title" content="Ringette Game" />
    <title>Ringette Game</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: Arial, sans-serif;
        background: #0a0a0a;
        color: white;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        padding: 10px;
        touch-action: none;
        -webkit-user-select: none;
        user-select: none;
        overflow: hidden;
        /* Safari fullscreen support */
        -webkit-overflow-scrolling: touch;
        -webkit-appearance: none;
        appearance: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        /* Prevent Safari bounce scrolling */
        overscroll-behavior: none;
        -webkit-touch-callout: none;
        -webkit-text-size-adjust: none;
      }

      #gameContainer {
        position: relative;
        max-width: 100%;
        max-height: 100%;
      }

      #gameCanvas {
        border: 3px solid #006194;
        background: #f0f8ff;
        display: block;
        touch-action: none;
      }

      #ui {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        pointer-events: none;
        z-index: 10;
      }

      .score-display {
        position: absolute;
        top: 20px;
        right: 20px;
        font-size: 24px;
        font-weight: bold;
        color: #006194;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px 15px;
        border-radius: 8px;
      }

      .shot-clock {
        position: absolute;
        top: 20px;
        left: 20px;
        font-size: 24px;
        font-weight: bold;
        color: white;
        background: rgba(0, 0, 0, 0.8);
        padding: 10px 15px;
        border-radius: 8px;
        min-width: 60px;
        text-align: center;
      }

      .instructions-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 20;
        pointer-events: auto;
      }

      .instructions-box {
        background: #000;
        border: 2px solid #fff;
        border-radius: 10px;
        padding: 20px;
        max-width: 80%;
        max-height: 80%;
        overflow-y: auto;
        position: relative;
      }

      .close-instructions {
        position: absolute;
        top: 10px;
        right: 15px;
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid #fff;
        border-radius: 50%;
        color: #fff;
        font-size: 20px;
        cursor: pointer;
        padding: 0;
        width: 25px;
        height: 25px;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        z-index: 30;
      }

      .close-instructions:hover {
        color: #ffd700;
        background: rgba(255, 215, 0, 0.2);
        border-color: #ffd700;
      }

      .close-instructions:active {
        transform: scale(0.95);
        background: rgba(255, 215, 0, 0.3);
      }

      .instructions-box h2 {
        margin-bottom: 15px;
        color: #fff;
        text-align: center;
        font-size: 20px;
      }

      .instructions-box p {
        margin-bottom: 8px;
        color: #fff;
        line-height: 1.4;
        font-size: 14px;
      }

      .instructions-box .start-button {
        background: #006194;
        color: white;
        border: 2px solid transparent;
        padding: 15px 30px;
        font-size: 18px;
        border-radius: 8px;
        cursor: pointer;
        display: block;
        margin: 20px auto 0;
        pointer-events: auto;
        min-width: 44px;
        min-height: 44px;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        transition: all 0.2s ease;
      }

      .instructions-box .start-button:hover {
        background: #004a73;
        border-color: #fff;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }

      .instructions-box .start-button:active {
        transform: translateY(0);
        background: #003d5c;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      /* Mobile controls */
      .mobile-controls {
        position: absolute;
        bottom: 20px;
        left: 80%;
        transform: translateX(-20%);
        display: none;
        gap: 20px;
        pointer-events: auto;
      }

      .mobile-button {
        background: rgba(0, 97, 148, 0.8);
        color: white;
        border: 2px solid #fff;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        min-width: 60px;
        min-height: 60px;
        font-size: 16px;
        cursor: pointer;
        touch-action: manipulation;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        -webkit-tap-highlight-color: transparent;
        transition: all 0.15s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        user-select: none;
        position: relative;
        overflow: hidden;
      }

      .mobile-button:active {
        background: rgba(0, 97, 148, 1);
        transform: scale(0.95);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
      }

      .mobile-button:hover {
        background: rgba(0, 97, 148, 0.9);
        border-color: #ffd700;
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
      }

      /* Ripple effect for mobile buttons */
      .mobile-button::after {
        content: "";
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.3);
        transform: scale(0);
        opacity: 0;
        transition: transform 0.3s ease, opacity 0.3s ease;
      }

      .mobile-button.pressed::after {
        transform: scale(1);
        opacity: 1;
        transition: transform 0.1s ease, opacity 0.1s ease;
      }

      /* Virtual joystick */
      .virtual-joystick {
        position: absolute;
        bottom: 20px;
        left: 20px;
        width: 120px;
        height: 120px;
        background: radial-gradient(
          circle,
          rgba(255, 255, 255, 0.15) 0%,
          rgba(255, 255, 255, 0.05) 100%
        );
        border: 3px solid rgba(255, 255, 255, 0.6);
        border-radius: 50%;
        display: none;
        pointer-events: auto;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }

      .joystick-knob {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 40px;
        height: 40px;
        background: radial-gradient(
          circle,
          rgba(0, 97, 148, 0.9) 0%,
          rgba(0, 97, 148, 0.7) 100%
        );
        border: 3px solid #fff;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        transition: all 0.1s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4),
          inset 0 1px 2px rgba(255, 255, 255, 0.3);
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }

      /* Always show mobile controls on mobile devices */
      .mobile-controls {
        display: none;
      }

      .virtual-joystick {
        display: none;
      }

      /* Responsive design */
      @media (max-width: 768px), (pointer: coarse) {
        .mobile-controls {
          display: flex !important;
        }

        .virtual-joystick {
          display: block !important;
        }

        .score-display {
          font-size: 18px;
          top: 10px;
          right: 10px;
          padding: 8px 12px;
        }

        .shot-clock {
          font-size: 18px;
          top: 10px;
          left: 10px;
          padding: 8px 12px;
        }

        #gameCanvas {
          max-width: 100vw;
          max-height: 70vh;
        }
      }

      @media (max-width: 480px) {
        .instructions-box {
          padding: 15px;
          max-width: 95%;
          max-height: 85%;
        }

        .instructions-box h2 {
          font-size: 18px;
          margin-bottom: 10px;
        }

        .instructions-box p {
          font-size: 13px;
          margin-bottom: 6px;
        }

        .instructions-box .start-button {
          padding: 15px 25px;
          font-size: 16px;
          min-width: 50px;
          min-height: 50px;
        }

        .close-instructions {
          width: 40px;
          height: 40px;
          font-size: 18px;
          top: 8px;
          right: 8px;
        }

        .score-display {
          font-size: 16px;
          padding: 6px 10px;
        }

        .shot-clock {
          font-size: 16px;
          padding: 6px 10px;
        }

        .mobile-button {
          width: 55px;
          height: 55px;
          min-width: 55px;
          min-height: 55px;
          font-size: 14px;
        }

        .virtual-joystick {
          width: 100px;
          height: 100px;
        }

        .joystick-knob {
          width: 35px;
          height: 35px;
        }
      }

      /* Safari mobile specific styles */
      @supports (-webkit-touch-callout: none) {
        body {
          /* Safari-specific fullscreen handling */
          height: -webkit-fill-available;
          min-height: -webkit-fill-available;
        }

        #gameContainer {
          height: -webkit-fill-available;
          min-height: -webkit-fill-available;
        }
      }

      /* Fullscreen mobile landscape styles */
      @media screen and (max-width: 900px) and (orientation: landscape) {
        html {
          height: 100%;
          overflow: hidden;
          -webkit-text-size-adjust: 100%;
        }

        body {
          padding: 0;
          min-height: 100vh;
          height: 100vh;
          width: 100vw;
          position: fixed;
          top: 0;
          left: 0;
          background: #0a0a0a;
          /* Enhanced Safari fullscreen */
          height: -webkit-fill-available;
          min-height: -webkit-fill-available;
          transform: translate3d(0, 0, 0);
        }

        #gameContainer {
          position: absolute;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          max-width: none;
          max-height: none;
          display: flex;
          align-items: center;
          justify-content: center;
          /* Safari fullscreen container */
          height: -webkit-fill-available;
          transform: translate3d(0, 0, 0);
        }

        #gameCanvas {
          width: 100vw !important;
          height: 100vh !important;
          max-width: 100vw !important;
          max-height: 100vh !important;
          border: none;
          border-radius: 0;
          /* Safari canvas fullscreen */
          height: -webkit-fill-available !important;
          transform: translate3d(0, 0, 0);
        }

        .score-display {
          top: max(env(safe-area-inset-top), 10px);
          right: max(env(safe-area-inset-right), 10px);
          font-size: 20px;
          background: rgba(255, 255, 255, 0.95);
          z-index: 15;
        }

        .shot-clock {
          top: max(env(safe-area-inset-top), 10px);
          left: max(env(safe-area-inset-left), 10px);
          font-size: 20px;
          background: rgba(0, 0, 0, 0.9);
          z-index: 15;
        }

        .mobile-controls {
          bottom: max(env(safe-area-inset-bottom), 20px);
          z-index: 15;
        }

        .virtual-joystick {
          bottom: max(env(safe-area-inset-bottom), 20px);
          left: max(env(safe-area-inset-left), 20px);
          z-index: 15;
        }
      }

      /* Portrait orientation warning on mobile */
      .orientation-warning {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.95);
        z-index: 50;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        color: white;
        padding: 20px;
      }

      .orientation-warning .rotate-icon {
        font-size: 80px;
        margin-bottom: 20px;
        animation: rotate 2s infinite linear;
      }

      @keyframes rotate {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      @media screen and (max-width: 900px) and (orientation: portrait) {
        .orientation-warning {
          display: flex !important;
        }
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="gameCanvas" width="800" height="600"></canvas>

      <div id="ui">
        <div class="score-display" id="scoreDisplay">Score: 0</div>
        <div class="shot-clock" id="shotClock">30s</div>
      </div>

      <div class="instructions-overlay" id="instructionsOverlay">
        <div class="instructions-box">
          <button class="close-instructions" id="closeInstructions">×</button>
          <h2>HOW TO PLAY RINGETTE</h2>
          <p><strong>Desktop Controls:</strong></p>
          <p>• ARROW KEYS or WASD: Move player</p>
          <p>• LEFT CLICK near ring: Pick up/Drop ring</p>
          <p>• SPACE: Shoot ring toward mouse cursor</p>
          <p>• ESC: Show/Hide instructions</p>
          <br />
          <p><strong>Mobile Controls:</strong></p>
          <p>• Virtual joystick: Move player</p>
          <p>• TAP near ring: Pick up/Drop ring</p>
          <p>• SHOOT button: Shoot ring forward</p>
          <br />
          <p><strong>Game Rules:</strong></p>
          <p>• Get close to the ring to pick it up</p>
          <p>• Score by shooting into the opponent's goals</p>
          <p>• 30-second shot clock resets on goals and shots</p>
          <p>• Goalies will try to block and throw the ring back</p>
          <button class="start-button" id="startButton">START GAME</button>
        </div>
      </div>

      <!-- Mobile Controls -->
      <div class="virtual-joystick" id="virtualJoystick">
        <div class="joystick-knob" id="joystickKnob"></div>
      </div>

      <div class="mobile-controls" id="mobileControls">
        <button class="mobile-button" id="pickupButton">RING</button>
        <button class="mobile-button" id="shootButton">SHOOT</button>
      </div>
    </div>

    <!-- Orientation warning for portrait mode on mobile -->
    <div class="orientation-warning" id="orientationWarning">
      <div class="rotate-icon">📱</div>
      <h2 style="margin-bottom: 20px">Rotate Your Device</h2>
      <p style="font-size: 18px; line-height: 1.5">
        For the best gaming experience,<br />
        please rotate your device to landscape mode.
      </p>
    </div>

    <script>
      // Game Constants (converted from Python)
      const RINK_BLUE = "#006194";
      const ICE_WHITE = "#F0F8FF";
      const RED_LINE = "#FF0000";
      const BLUE_LINE = "#0000FF";
      const RING_COLOR = "#0000FF";
      const PLAYER_COLOR = "#FF0000";

      const RINK_WIDTH = 800;
      const RINK_HEIGHT = 600;
      const CENTER_LINE_Y = RINK_HEIGHT / 2;
      const BLUE_LINE_1_X = RINK_WIDTH / 3;
      const BLUE_LINE_2_X = (RINK_WIDTH * 2) / 3;
      const GOAL_LINE_1_X = 50;
      const GOAL_LINE_2_X = RINK_WIDTH - 50;

      const PLAYER_WIDTH = 40;
      const PLAYER_HEIGHT = 40;
      const PLAYER_SPEED = 5;
      const RING_SPEED = 5;
      const CIRCLE_RADIUS = 60;
      const DOT_RADIUS = 6;
      const DOT_OFFSET = CIRCLE_RADIUS / 2;
      const PICKUP_RANGE = 70;
      const SHOT_CLOCK_DURATION = 30;

      // Game Variables
      let canvas, ctx;
      let gameRunning = false;
      let showInstructions = true;
      let score = 0;
      let shotClock = SHOT_CLOCK_DURATION;
      let lastTime = 0;
      let lastShotClockUpdate = 0;
      let ringPickedUpSinceGoal = false;

      // Input handling
      let keys = {};
      let mousePos = { x: 0, y: 0 };
      let isMobile =
        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent
        ) || window.innerWidth <= 768;

      // Detect Safari mobile specifically
      let isSafariMobile =
        /iPhone|iPad|iPod/i.test(navigator.userAgent) &&
        /Safari/i.test(navigator.userAgent) &&
        !/Chrome|CriOS|FxiOS/i.test(navigator.userAgent);

      // Mobile controls
      let joystickActive = false;
      let joystickCenter = { x: 0, y: 0 };
      let joystickInput = { x: 0, y: 0 };

      // Game Objects
      let player, ring, goal1, goal2, goalie1, goalie2;

      // Load lynx logo
      let lynxLogo = new Image();
      lynxLogo.src = "lynxLogo.svg";
      let logoLoaded = false;
      lynxLogo.onload = function () {
        logoLoaded = true;
      };

      // Player Class
      class Player {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.width = PLAYER_WIDTH;
          this.height = PLAYER_HEIGHT;
          this.hasRing = false;
          this.direction = [1, 0];
        }

        update(frameMultiplier = 1) {
          let dx = 0,
            dy = 0;

          // Desktop controls
          if (keys["ArrowLeft"] || keys["KeyA"]) {
            dx = -PLAYER_SPEED * frameMultiplier;
            this.direction = [-1, 0];
          }
          if (keys["ArrowRight"] || keys["KeyD"]) {
            dx = PLAYER_SPEED * frameMultiplier;
            this.direction = [1, 0];
          }
          if (keys["ArrowUp"] || keys["KeyW"]) {
            dy = -PLAYER_SPEED * frameMultiplier;
            this.direction = [0, -1];
          }
          if (keys["ArrowDown"] || keys["KeyS"]) {
            dy = PLAYER_SPEED * frameMultiplier;
            this.direction = [0, 1];
          }

          // Mobile controls with enhanced sensitivity
          if (
            isMobile &&
            (Math.abs(joystickInput.x) > 0.05 ||
              Math.abs(joystickInput.y) > 0.05)
          ) {
            // Apply easing function for smoother movement
            const sensitivityCurve = (input) => {
              const absInput = Math.abs(input);
              if (absInput < 0.1) return 0;
              // Use quadratic easing for better feel
              const sign = input > 0 ? 1 : -1;
              const result =
                sign * (absInput * absInput * 0.8 + absInput * 0.2);

              return result;
            };

            const rawDx =
              sensitivityCurve(joystickInput.x) *
              PLAYER_SPEED *
              frameMultiplier;
            const rawDy =
              sensitivityCurve(joystickInput.y) *
              PLAYER_SPEED *
              frameMultiplier;

            dx = rawDx;
            dy = rawDy;

            // Update direction based on movement
            if (Math.abs(dx) > Math.abs(dy)) {
              this.direction = dx > 0 ? [1, 0] : [-1, 0];
            } else if (Math.abs(dy) > 0.1) {
              this.direction = dy > 0 ? [0, 1] : [0, -1];
            }
          }

          // Apply movement
          this.x += dx;
          this.y += dy;

          // Keep player on screen
          this.x = Math.max(0, Math.min(RINK_WIDTH - this.width, this.x));
          this.y = Math.max(0, Math.min(RINK_HEIGHT - this.height, this.y));
        }

        getShootDirection() {
          // Calculate direction from ring to mouse/joystick direction
          if (isMobile) {
            // For mobile, shoot in the direction of the joystick
            if (
              Math.abs(joystickInput.x) > 0.1 ||
              Math.abs(joystickInput.y) > 0.1
            ) {
              // Use current joystick direction for shooting
              const length = Math.sqrt(
                joystickInput.x * joystickInput.x +
                  joystickInput.y * joystickInput.y
              );
              if (length > 0) {
                return [joystickInput.x / length, joystickInput.y / length];
              }
            }
            // Fallback to player facing direction if joystick is not being used
            return this.direction;
          } else {
            // For desktop, shoot toward mouse from ring position
            const ringX = this.x + this.width - 10 + 10; // Ring center X (ring.x + ring.width/2)
            const ringY = this.y + this.height - 10 + 10; // Ring center Y (ring.y + ring.height/2)
            const dx = mousePos.x - ringX;
            const dy = mousePos.y - ringY;
            const length = Math.sqrt(dx * dx + dy * dy);
            if (length > 0) {
              return [dx / length, dy / length];
            }
          }
          return [1, 0];
        }

        draw() {
          if (logoLoaded) {
            // Draw the lynx logo scaled to player size
            ctx.drawImage(lynxLogo, this.x, this.y, this.width, this.height);
          } else {
            // Fallback: draw a simple player shape while logo loads
            ctx.fillStyle = PLAYER_COLOR;
            ctx.fillRect(this.x, this.y, this.width, this.height);

            // Draw stick
            ctx.strokeStyle = "#8B4513";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(this.x + this.width / 2, this.y + this.height / 2);
            ctx.lineTo(this.x + this.width, this.y + this.height / 2);
            ctx.stroke();
          }
        }
      }

      // Ring Class
      class Ring {
        constructor() {
          this.x = RINK_WIDTH / 2 - DOT_OFFSET;
          this.y = RINK_HEIGHT / 2;
          this.width = 20;
          this.height = 20;
          this.velocity = [0, 0];
          this.active = false;
          this.decayFactor = 0.99;
        }

        update(frameMultiplier = 1) {
          if (this.active) {
            this.velocity[0] *= this.decayFactor;
            this.velocity[1] *= this.decayFactor;

            if (
              Math.abs(this.velocity[0]) < 0.1 &&
              Math.abs(this.velocity[1]) < 0.1
            ) {
              this.velocity = [0, 0];
            }

            // Apply velocity with frame-rate independence
            this.x += this.velocity[0] * frameMultiplier;
            this.y += this.velocity[1] * frameMultiplier;

            // Bounce off walls
            if (this.x < 0 || this.x > RINK_WIDTH - this.width) {
              this.velocity[0] *= -1;
            }
            if (this.y < 0 || this.y > RINK_HEIGHT - this.height) {
              this.velocity[1] *= -1;
            }

            // Keep ring on screen
            this.x = Math.max(0, Math.min(RINK_WIDTH - this.width, this.x));
            this.y = Math.max(0, Math.min(RINK_HEIGHT - this.height, this.y));
          }
        }

        draw() {
          // Draw blue ring with white center
          ctx.fillStyle = RING_COLOR;
          ctx.beginPath();
          ctx.arc(
            this.x + this.width / 2,
            this.y + this.height / 2,
            10,
            0,
            2 * Math.PI
          );
          ctx.fill();

          ctx.fillStyle = ICE_WHITE;
          ctx.beginPath();
          ctx.arc(
            this.x + this.width / 2,
            this.y + this.height / 2,
            5,
            0,
            2 * Math.PI
          );
          ctx.fill();
        }
      }

      // Goal Class
      class Goal {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.width = 20;
          this.height = 100;
        }

        draw() {
          ctx.fillStyle = RINK_BLUE;
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }

        checkCollision(ring) {
          return (
            ring.x < this.x + this.width &&
            ring.x + ring.width > this.x &&
            ring.y < this.y + this.height &&
            ring.y + ring.height > this.y
          );
        }
      }

      // Goalie Class
      class Goalie {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.width = 20;
          this.height = 40;
          this.speed = 1;
          this.direction = 1;
          this.goalTop = RINK_HEIGHT / 2 - 50;
          this.goalBottom = RINK_HEIGHT / 2 + 50;
          this.hasRing = false;
          this.holdTime = 0;
          this.throwDirection = [0, 0];
          this.throwCooldown = 0;
        }

        update() {
          if (!this.hasRing) {
            this.y += this.speed * this.direction;

            if (this.y <= this.goalTop) {
              this.direction = 1;
            } else if (this.y + this.height >= this.goalBottom) {
              this.direction = -1;
            }

            if (this.throwCooldown > 0) {
              this.throwCooldown--;
            }
          }

          if (this.hasRing) {
            this.holdTime++;
            if (this.holdTime >= 180) {
              // 3 seconds at 60 FPS
              this.hasRing = false;
              this.throwCooldown = 120; // 2 second cooldown
              this.holdTime = 0;
              return this.throwDirection;
            }
          }
          return null;
        }

        canCatch() {
          return !this.hasRing && this.throwCooldown === 0;
        }

        checkCollision(ring) {
          return (
            ring.x < this.x + this.width &&
            ring.x + ring.width > this.x &&
            ring.y < this.y + this.height &&
            ring.y + ring.height > this.y
          );
        }

        draw() {
          // Draw goalie with red jersey
          ctx.fillStyle = "#DC1414";
          ctx.fillRect(this.x + 5, this.y + 10, 10, 20); // Body

          // Head
          ctx.fillStyle = "#FFDBBA";
          ctx.beginPath();
          ctx.arc(this.x + 10, this.y + 7, 5, 0, 2 * Math.PI);
          ctx.fill();

          // Arms and stick
          ctx.strokeStyle = "#DC1414";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(this.x + 5, this.y + 15);
          ctx.lineTo(this.x + 3, this.y + 25);
          ctx.moveTo(this.x + 15, this.y + 15);
          ctx.lineTo(this.x + 17, this.y + 25);
          ctx.stroke();

          // Goalie stick
          ctx.strokeStyle = "#8B4513";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(this.x + 3, this.y + 25);
          ctx.lineTo(this.x + 17, this.y + 25);
          ctx.stroke();

          // Legs
          ctx.strokeStyle = "#000";
          ctx.beginPath();
          ctx.moveTo(this.x + 7, this.y + 30);
          ctx.lineTo(this.x + 7, this.y + 38);
          ctx.moveTo(this.x + 13, this.y + 30);
          ctx.lineTo(this.x + 13, this.y + 38);
          ctx.stroke();
        }
      }

      // Draw rink function
      function drawRink() {
        // Clear canvas with ice white
        ctx.fillStyle = ICE_WHITE;
        ctx.fillRect(0, 0, RINK_WIDTH, RINK_HEIGHT);

        // Draw rink outline
        ctx.strokeStyle = RINK_BLUE;
        ctx.lineWidth = 15;
        ctx.strokeRect(0, 0, RINK_WIDTH, RINK_HEIGHT);

        // Center line
        ctx.strokeStyle = RED_LINE;
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(RINK_WIDTH / 2, 0);
        ctx.lineTo(RINK_WIDTH / 2, RINK_HEIGHT);
        ctx.stroke();

        // Blue lines
        ctx.strokeStyle = BLUE_LINE;
        ctx.lineWidth = 10;
        const blueLine1X = RINK_WIDTH / 2 - 100;
        const blueLine2X = RINK_WIDTH / 2 + 100;

        ctx.beginPath();
        ctx.moveTo(blueLine1X, 0);
        ctx.lineTo(blueLine1X, RINK_HEIGHT);
        ctx.moveTo(blueLine2X, 0);
        ctx.lineTo(blueLine2X, RINK_HEIGHT);
        ctx.stroke();

        // Goal lines
        ctx.strokeStyle = RED_LINE;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(GOAL_LINE_1_X, 0);
        ctx.lineTo(GOAL_LINE_1_X, RINK_HEIGHT);
        ctx.moveTo(GOAL_LINE_2_X, 0);
        ctx.lineTo(GOAL_LINE_2_X, RINK_HEIGHT);
        ctx.stroke();

        // Face-off circles
        ctx.strokeStyle = BLUE_LINE;
        ctx.lineWidth = 2;

        // Center circle
        ctx.beginPath();
        ctx.arc(RINK_WIDTH / 2, RINK_HEIGHT / 2, CIRCLE_RADIUS, 0, 2 * Math.PI);
        ctx.stroke();

        // Center dots
        ctx.fillStyle = BLUE_LINE;
        ctx.beginPath();
        ctx.arc(
          RINK_WIDTH / 2 - DOT_OFFSET,
          RINK_HEIGHT / 2,
          DOT_RADIUS,
          0,
          2 * Math.PI
        );
        ctx.fill();
        ctx.beginPath();
        ctx.arc(
          RINK_WIDTH / 2 + DOT_OFFSET,
          RINK_HEIGHT / 2,
          DOT_RADIUS,
          0,
          2 * Math.PI
        );
        ctx.fill();

        // Other face-off circles
        const rightFaceOff = RINK_WIDTH / 2 - 280;
        const leftFaceOff = RINK_WIDTH / 2 + 280;
        const higherFaceOff = RINK_HEIGHT / 4;
        const lowerFaceOff = (RINK_HEIGHT * 3) / 4;

        // Draw face-off circles and dots
        const faceOffPositions = [
          [rightFaceOff, higherFaceOff],
          [leftFaceOff, higherFaceOff],
          [rightFaceOff, lowerFaceOff],
          [leftFaceOff, lowerFaceOff],
        ];

        faceOffPositions.forEach(([x, y]) => {
          ctx.strokeStyle = BLUE_LINE;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(x, y, CIRCLE_RADIUS, 0, 2 * Math.PI);
          ctx.stroke();

          // Vertical line through circle
          ctx.beginPath();
          ctx.moveTo(x, y - CIRCLE_RADIUS);
          ctx.lineTo(x, y + CIRCLE_RADIUS);
          ctx.stroke();

          // Dots
          ctx.fillStyle = BLUE_LINE;
          ctx.beginPath();
          ctx.arc(x - DOT_OFFSET, y, DOT_RADIUS, 0, 2 * Math.PI);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(x + DOT_OFFSET, y, DOT_RADIUS, 0, 2 * Math.PI);
          ctx.fill();
        });

        // Goal creases
        ctx.strokeStyle = BLUE_LINE;
        ctx.lineWidth = 3;
        const creaseRadius = 60;

        // Left crease
        ctx.beginPath();
        ctx.arc(
          GOAL_LINE_1_X,
          RINK_HEIGHT / 2,
          creaseRadius,
          -Math.PI / 2,
          Math.PI / 2
        );
        ctx.stroke();

        // Right crease
        ctx.beginPath();
        ctx.arc(
          GOAL_LINE_2_X,
          RINK_HEIGHT / 2,
          creaseRadius,
          Math.PI / 2,
          (3 * Math.PI) / 2
        );
        ctx.stroke();

        // Free play lines
        ctx.strokeStyle = RED_LINE;
        ctx.lineWidth = 3;
        const freePlayDistance = 150;

        ctx.beginPath();
        ctx.moveTo(GOAL_LINE_1_X + freePlayDistance, 0);
        ctx.lineTo(GOAL_LINE_1_X + freePlayDistance, RINK_HEIGHT);
        ctx.moveTo(GOAL_LINE_2_X - freePlayDistance, 0);
        ctx.lineTo(GOAL_LINE_2_X - freePlayDistance, RINK_HEIGHT);
        ctx.stroke();
      }

      // Initialize game
      function initGame() {
        canvas = document.getElementById("gameCanvas");
        ctx = canvas.getContext("2d");

        // Scale canvas for mobile
        if (isMobile) {
          const isLandscape =
            window.orientation === 90 ||
            window.orientation === -90 ||
            (window.matchMedia &&
              window.matchMedia("(orientation: landscape)").matches);

          if (isLandscape) {
            // Landscape mode - fullscreen
            let canvasWidth = window.innerWidth;
            let canvasHeight = window.innerHeight;

            // Safari-specific viewport handling
            if (isSafariMobile) {
              // Use viewport dimensions that account for Safari's interface
              canvasWidth = Math.max(window.innerWidth, window.screen.width);
              canvasHeight = Math.max(
                window.innerHeight,
                window.screen.height - 140
              ); // Account for Safari UI

              // Force Safari to use available space
              setTimeout(() => {
                canvas.style.width = canvasWidth + "px";
                canvas.style.height = canvasHeight + "px";
              }, 100);
            }

            canvas.style.width = canvasWidth + "px";
            canvas.style.height = canvasHeight + "px";

            // Ensure proper aspect ratio scaling
            const scaleX = canvasWidth / RINK_WIDTH;
            const scaleY = canvasHeight / RINK_HEIGHT;
            const optimalScale = Math.min(scaleX, scaleY);

            // Apply scaling while maintaining center positioning
            const finalWidth = RINK_WIDTH * optimalScale;
            const finalHeight = RINK_HEIGHT * optimalScale;
            canvas.style.width = finalWidth + "px";
            canvas.style.height = finalHeight + "px";
          } else {
            // Portrait mode - regular scaling
            const scale = Math.min(
              window.innerWidth / RINK_WIDTH,
              (window.innerHeight * 0.7) / RINK_HEIGHT
            );
            canvas.style.width = RINK_WIDTH * scale + "px";
            canvas.style.height = RINK_HEIGHT * scale + "px";
          }
        }

        // Create game objects
        player = new Player(RINK_WIDTH / 2 - 100, RINK_HEIGHT / 2);
        ring = new Ring();
        goal1 = new Goal(GOAL_LINE_1_X - 20, RINK_HEIGHT / 2 - 50);
        goal2 = new Goal(GOAL_LINE_2_X, RINK_HEIGHT / 2 - 50);
        goalie1 = new Goalie(GOAL_LINE_1_X + 30, RINK_HEIGHT / 2 - 30);
        goalie2 = new Goalie(GOAL_LINE_2_X - 30, RINK_HEIGHT / 2 - 30);

        setupEventListeners();
        setupOrientationHandling();
        gameLoop(0);
      }

      // Handle orientation changes and fullscreen
      function setupOrientationHandling() {
        function handleOrientationChange() {
          setTimeout(() => {
            if (isMobile) {
              // Safari-specific fullscreen handling
              if (isSafariMobile) {
                // Force Safari to hide address bar
                window.scrollTo(0, 1);
                setTimeout(() => window.scrollTo(0, 0), 100);
              }
              initGame(); // Reinitialize with new orientation
            }
          }, 300); // Increased delay for Safari
        }

        // Listen for orientation changes
        window.addEventListener("orientationchange", handleOrientationChange);
        window.addEventListener("resize", handleOrientationChange);

        // Safari-specific scroll prevention
        if (isSafariMobile) {
          // Prevent Safari bounce scrolling
          let startY = 0;
          document.addEventListener(
            "touchstart",
            function (e) {
              startY = e.touches[0].pageY;
            },
            { passive: false }
          );

          document.addEventListener(
            "touchmove",
            function (e) {
              const y = e.touches[0].pageY;
              // Only prevent if trying to scroll past boundaries
              if (
                (y > startY && window.pageYOffset === 0) ||
                (y < startY &&
                  window.pageYOffset + window.innerHeight >=
                    document.body.scrollHeight)
              ) {
                e.preventDefault();
              }
            },
            { passive: false }
          );

          // Hide Safari address bar on load
          setTimeout(() => {
            window.scrollTo(0, 1);
            setTimeout(() => window.scrollTo(0, 0), 100);
          }, 500);
        }

        // Try to enter fullscreen on mobile when game starts
        function attemptFullscreen() {
          if (isMobile && document.documentElement.requestFullscreen) {
            document.documentElement.requestFullscreen().catch(() => {
              // Fullscreen failed, but that's okay
            });
          } else if (
            isMobile &&
            document.documentElement.webkitRequestFullscreen
          ) {
            document.documentElement.webkitRequestFullscreen();
          }

          // Safari-specific fullscreen attempt
          if (isSafariMobile) {
            // Try to trigger Safari fullscreen mode
            setTimeout(() => {
              window.scrollTo(0, 1);
              setTimeout(() => window.scrollTo(0, 0), 200);
            }, 1000);
          }
        }

        // Add fullscreen attempt to start game
        const originalStartGame = window.startGame;
        window.startGame = function () {
          originalStartGame();
          if (isMobile) {
            attemptFullscreen();
          }
        };
      }

      // Event Listeners
      function setupEventListeners() {
        // Keyboard events
        document.addEventListener("keydown", (e) => {
          keys[e.code] = true;

          if (e.code === "Space" && player.hasRing && gameRunning) {
            e.preventDefault();
            shootRing();
          }

          if (e.code === "Escape") {
            e.preventDefault();
            showInstructions = !showInstructions;
            document.getElementById("instructionsOverlay").style.display =
              showInstructions ? "flex" : "none";
          }
        });

        document.addEventListener("keyup", (e) => {
          keys[e.code] = false;
        });

        // Mouse events
        canvas.addEventListener("mousemove", (e) => {
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;

          mousePos.x = (e.clientX - rect.left) * scaleX;
          mousePos.y = (e.clientY - rect.top) * scaleY;
        });

        // Handle both click and touch for ring pickup
        function handleCanvasTouch(e) {
          if (!gameRunning) return;
          e.preventDefault();

          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;

          let clientX, clientY;
          if (e.type === "touchstart" || e.type === "touchend") {
            const touch = e.touches[0] || e.changedTouches[0];
            clientX = touch.clientX;
            clientY = touch.clientY;
          } else {
            clientX = e.clientX;
            clientY = e.clientY;
          }

          const clickX = (clientX - rect.left) * scaleX;
          const clickY = (clientY - rect.top) * scaleY;

          handleRingPickup(clickX, clickY);
        }

        canvas.addEventListener("click", handleCanvasTouch);
        canvas.addEventListener("touchend", handleCanvasTouch);

        // Always setup mobile controls (CSS will show/hide them)
        setupMobileControls();

        // Start button - handle both touch and click events
        function startGameHandler(e) {
          e.preventDefault();
          startGame();
        }

        const startBtn = document.getElementById("startButton");
        startBtn.addEventListener("click", startGameHandler);
        startBtn.addEventListener("touchstart", (e) => {
          e.preventDefault();
          startBtn.style.transform = "translateY(0)";
          startBtn.style.background = "#003d5c";
        });
        startBtn.addEventListener("touchend", startGameHandler);
        startBtn.addEventListener("touchcancel", (e) => {
          e.preventDefault();
          startBtn.style.transform = "";
          startBtn.style.background = "#006194";
        });

        // Close instructions button - handle both touch and click events
        function closeInstructionsHandler(e) {
          e.preventDefault();
          showInstructions = false;
          document.getElementById("instructionsOverlay").style.display = "none";
        }

        const closeBtn = document.getElementById("closeInstructions");
        closeBtn.addEventListener("click", closeInstructionsHandler);
        closeBtn.addEventListener("touchstart", (e) => {
          e.preventDefault();
          closeBtn.style.background = "rgba(255, 215, 0, 0.3)";
        });
        closeBtn.addEventListener("touchend", closeInstructionsHandler);
        closeBtn.addEventListener("touchcancel", (e) => {
          e.preventDefault();
          closeBtn.style.background = "rgba(0, 0, 0, 0.5)";
        });
      }

      // Mobile controls setup
      function setupMobileControls() {
        const joystick = document.getElementById("virtualJoystick");
        const knob = document.getElementById("joystickKnob");

        joystick.addEventListener("touchstart", (e) => {
          e.preventDefault();
          joystickActive = true;
          const rect = joystick.getBoundingClientRect();
          joystickCenter.x = rect.left + rect.width / 2;
          joystickCenter.y = rect.top + rect.height / 2;
        });

        joystick.addEventListener("touchmove", (e) => {
          if (!joystickActive) return;
          e.preventDefault();

          const touch = e.touches[0];
          const dx = touch.clientX - joystickCenter.x;
          const dy = touch.clientY - joystickCenter.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const maxDistance = 50; // Adjusted for better joystick response

          if (distance <= maxDistance) {
            joystickInput.x = dx / maxDistance;
            joystickInput.y = dy / maxDistance;
            knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
          } else {
            const angle = Math.atan2(dy, dx);
            const limitedX = Math.cos(angle) * maxDistance;
            const limitedY = Math.sin(angle) * maxDistance;
            joystickInput.x = limitedX / maxDistance;
            joystickInput.y = limitedY / maxDistance;
            knob.style.transform = `translate(calc(-50% + ${limitedX}px), calc(-50% + ${limitedY}px))`;
          }
        });

        function resetJoystick(e) {
          e.preventDefault();
          joystickActive = false;
          joystickInput.x = 0;
          joystickInput.y = 0;
          knob.style.transform = "translate(-50%, -50%)";
        }

        joystick.addEventListener("touchend", resetJoystick);
        joystick.addEventListener("touchcancel", resetJoystick);

        // Mobile buttons - handle both touch and click
        function setupMobileButtons() {
          const pickupBtn = document.getElementById("pickupButton");
          const shootBtn = document.getElementById("shootButton");

          function addRippleEffect(button) {
            button.classList.add("pressed");
            setTimeout(() => {
              button.classList.remove("pressed");
            }, 300);
          }

          function handlePickup(e) {
            e.preventDefault();

            if (!gameRunning) return;

            addRippleEffect(pickupBtn);
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            handleRingPickup(playerCenterX, playerCenterY);
          }

          function handleShoot(e) {
            e.preventDefault();

            if (player.hasRing && gameRunning) {
              addRippleEffect(shootBtn);
              shootRing();
            }
          }

          // Enhanced touch handling for pickup button
          pickupBtn.addEventListener("touchstart", (e) => {
            e.preventDefault();
            pickupBtn.style.transform = "scale(0.95)";
          });
          pickupBtn.addEventListener("touchend", handlePickup);
          pickupBtn.addEventListener("touchcancel", (e) => {
            e.preventDefault();
            pickupBtn.style.transform = "";
          });
          pickupBtn.addEventListener("click", handlePickup);

          // Enhanced touch handling for shoot button
          shootBtn.addEventListener("touchstart", (e) => {
            e.preventDefault();
            shootBtn.style.transform = "scale(0.95)";
          });
          shootBtn.addEventListener("touchend", handleShoot);
          shootBtn.addEventListener("touchcancel", (e) => {
            e.preventDefault();
            shootBtn.style.transform = "";
          });
          shootBtn.addEventListener("click", handleShoot);
        }

        setupMobileButtons();

        // Enhanced scroll prevention for all mobile browsers
        function preventDefaultTouch(e) {
          // Don't prevent touch events on interactive game elements
          const gameElements = [
            "virtualJoystick",
            "joystickKnob",
            "pickupButton",
            "shootButton",
            "startButton",
            "closeInstructions",
          ];
          const isGameElement = gameElements.some(
            (id) => e.target.id === id || e.target.closest(`#${id}`)
          );

          if (!isGameElement && !e.target.closest(".instructions-overlay")) {
            e.preventDefault();
          }
        }

        // Apply to document for comprehensive coverage
        document.addEventListener("touchstart", preventDefaultTouch, {
          passive: false,
        });
        document.addEventListener("touchmove", preventDefaultTouch, {
          passive: false,
        });
        document.addEventListener("touchend", preventDefaultTouch, {
          passive: false,
        });

        // Additional prevention for Safari
        if (isSafariMobile) {
          document.addEventListener("gesturestart", (e) => e.preventDefault(), {
            passive: false,
          });
          document.addEventListener(
            "gesturechange",
            (e) => e.preventDefault(),
            { passive: false }
          );
          document.addEventListener("gestureend", (e) => e.preventDefault(), {
            passive: false,
          });
        }
      }

      // Game functions
      function startGame() {
        gameRunning = true;
        showInstructions = false;
        document.getElementById("instructionsOverlay").style.display = "none";
      }

      function shootRing() {
        player.hasRing = false;
        ring.active = true;

        // Position ring at the end of the stick (bottom-right of player)
        ring.x = player.x + player.width - 10;
        ring.y = player.y + player.height - 10;

        const direction = player.getShootDirection();
        const velocityX = direction[0] * RING_SPEED;
        const velocityY = direction[1] * RING_SPEED;
        ring.velocity = [velocityX, velocityY];
        ring.decayFactor = 0.99;
        shotClock = SHOT_CLOCK_DURATION;
      }

      function handleRingPickup(x, y) {
        const ringCenterX = ring.x + ring.width / 2;
        const ringCenterY = ring.y + ring.height / 2;
        const dx = ringCenterX - x;
        const dy = ringCenterY - y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance <= PICKUP_RANGE) {
          player.hasRing = !player.hasRing;

          if (player.hasRing) {
            // Picking up the ring
            ring.x = player.x + player.width - 10;
            ring.y = player.y + player.height - 10;
            ring.active = false;
            ring.velocity = [0, 0];
            ringPickedUpSinceGoal = true;
          }
        }
      }

      function checkGoals() {
        if (!ring.active) return;

        if (goal1.checkCollision(ring)) {
          score++;
          ring.active = false;
          ring.x = RINK_WIDTH / 2 - DOT_OFFSET;
          ring.y = RINK_HEIGHT / 2;
          ring.velocity = [0, 0];
          shotClock = SHOT_CLOCK_DURATION;
          ringPickedUpSinceGoal = false;
          updateScore();
        } else if (goal2.checkCollision(ring)) {
          score++;
          ring.active = false;
          ring.x = RINK_WIDTH / 2 + DOT_OFFSET;
          ring.y = RINK_HEIGHT / 2;
          ring.velocity = [0, 0];
          shotClock = SHOT_CLOCK_DURATION;
          ringPickedUpSinceGoal = false;
          updateScore();
        }
      }

      function checkGoalieInteractions() {
        if (!ring.active) return;

        // Check goalie1
        if (goalie1.checkCollision(ring) && goalie1.canCatch()) {
          if (Math.random() < 0.7) {
            ring.active = false;
            goalie1.hasRing = true;
            goalie1.holdTime = 0;
            goalie1.throwDirection = [1, Math.random() * 2 - 1];
            ring.x = goalie1.x;
            ring.y = goalie1.y;
          } else {
            ring.velocity[0] *= -1;
            ring.velocity[1] *= -1;
            ring.velocity[0] += (Math.random() - 0.5) * 2;
            ring.velocity[1] += (Math.random() - 0.5) * 2;
            ring.decayFactor = 0.98;
          }
          shotClock = SHOT_CLOCK_DURATION;
        }

        // Check goalie2
        if (goalie2.checkCollision(ring) && goalie2.canCatch()) {
          if (Math.random() < 0.7) {
            ring.active = false;
            goalie2.hasRing = true;
            goalie2.holdTime = 0;
            goalie2.throwDirection = [-1, Math.random() * 2 - 1];
            ring.x = goalie2.x;
            ring.y = goalie2.y;
          } else {
            ring.velocity[0] *= -1;
            ring.velocity[1] *= -1;
            ring.velocity[0] += (Math.random() - 0.5) * 2;
            ring.velocity[1] += (Math.random() - 0.5) * 2;
            ring.decayFactor = 0.98;
          }
          shotClock = SHOT_CLOCK_DURATION;
        }
      }

      function updateGoalies() {
        const throwDirection1 = goalie1.update();
        if (throwDirection1) {
          ring.active = true;
          ring.x = goalie1.x + 20;
          ring.y = goalie1.y + goalie1.height / 2;
          ring.velocity = [
            throwDirection1[0] * RING_SPEED * 0.5,
            throwDirection1[1] * RING_SPEED * 0.5,
          ];
          ring.decayFactor = 0.98;
          shotClock = SHOT_CLOCK_DURATION;
        }

        const throwDirection2 = goalie2.update();
        if (throwDirection2) {
          ring.active = true;
          ring.x = goalie2.x - 20;
          ring.y = goalie2.y + goalie2.height / 2;
          ring.velocity = [
            throwDirection2[0] * RING_SPEED * 0.5,
            throwDirection2[1] * RING_SPEED * 0.5,
          ];
          ring.decayFactor = 0.98;
          shotClock = SHOT_CLOCK_DURATION;
        }
      }

      function updateScore() {
        document.getElementById("scoreDisplay").textContent = `Score: ${score}`;
      }

      function updateShotClock() {
        document.getElementById("shotClock").textContent = `${shotClock}s`;
      }

      // Main game loop
      function gameLoop(currentTime) {
        // Initialize lastTime on first frame
        if (lastTime === 0) {
          lastTime = currentTime;
          requestAnimationFrame(gameLoop);
          return;
        }

        // Calculate delta time for frame-rate independent movement
        const deltaTime = currentTime - lastTime;
        const frameMultiplier = deltaTime / 16.67; // 16.67ms = 60 FPS baseline

        if (gameRunning) {
          // Update shot clock (track separately from frame timing)
          if (currentTime - lastShotClockUpdate >= 1000) {
            if (ringPickedUpSinceGoal) {
              shotClock--;
              if (shotClock <= 0) {
                player.hasRing = false;
                ring.active = false;
                ring.velocity = [0, 0];
                ring.x = RINK_WIDTH / 2 - DOT_OFFSET;
                ring.y = RINK_HEIGHT / 2;
                shotClock = SHOT_CLOCK_DURATION;
                ringPickedUpSinceGoal = false;
              }
            }
            updateShotClock();
            lastShotClockUpdate = currentTime;
          }

          // Update game objects with frame-rate independent movement
          player.update(frameMultiplier);
          ring.update(frameMultiplier);
          updateGoalies();

          // Update ring position if player has it
          if (player.hasRing && !ring.active) {
            // Position ring at the end of the stick (bottom-right of player)
            ring.x = player.x + player.width - 10; // Ring's left edge near player's right edge
            ring.y = player.y + player.height - 10; // Ring's top edge near player's bottom edge
          }

          // Check collisions
          checkGoals();
          checkGoalieInteractions();
        } else {
          // Allow player movement testing during instructions screen
          if (isMobile) {
            player.update(frameMultiplier);

            // Update ring position if player has it
            if (player.hasRing && !ring.active) {
              // Position ring at the end of the stick (bottom-right of player)
              ring.x = player.x + player.width - 10;
              ring.y = player.y + player.height - 10;
            }
          }
        }

        // Draw everything
        drawRink();
        goal1.draw();
        goal2.draw();
        goalie1.draw();
        goalie2.draw();
        ring.draw();
        player.draw();

        // Update lastTime for next frame
        lastTime = currentTime;

        requestAnimationFrame(gameLoop);
      }

      // Initialize when page loads
      window.addEventListener("load", initGame);
    </script>
  </body>
</html>
